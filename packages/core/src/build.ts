/**
 * Copyright (c) Jonas Franke and the ContentKit Contributors
 * SPDX-License-Identifier: BSD-3-Clause
 */

import fs from "node:fs/promises";
import fsSync from "node:fs";
import path from "node:path";
import process from "node:process";
import { marked } from "marked";
import { loadConfig } from "@ckjs/utils/load-config";
import { logger, colors } from "@ckjs/utils/logger";
import { parseInternal as parseFrontmatter } from "@ckjs/matter";
import type { ContentKitConfig, ParsedContent } from "@ckjs/types";
import { validateFieldType } from "./utils/validateFieldType";
import { generateTypeScriptTypesFile } from "./utils/generateTypeScriptTypesFile";
import { generateIndexTypesFile } from "./utils/generateIndexTypesFile";
import { generateIndexFile } from "./utils/generateIndexFile";

export async function build(config: ContentKitConfig) {
  const { globby } = await import("globby");

  const output: ParsedContent[] = [];
  const cacheDir = path.join(".contentkit", ".cache");
  const generatedDir = path.join(".contentkit", "generated");
  const packageJsonPath = path.join(".contentkit", "package.json");

  await Promise.all([
    fs.mkdir(cacheDir, { recursive: true }),
    fs.mkdir(generatedDir, { recursive: true }),
  ]);

  const randomVersion = `0.0.0-${Math.random().toString(36).substring(2, 10).toUpperCase()}`;

  const packageJsonContent = {
    name: "dot-contentkit",
    description: "This package is auto-generated by ContentKit",
    version: randomVersion,
    exports: {
      "./generated": {
        import: "./generated/index.js",
      },
    },
    typesVersions: {
      "*": {
        generated: ["./generated"],
      },
    },
  };

  await fs.writeFile(
    packageJsonPath,
    JSON.stringify(packageJsonContent, null, 2),
    "utf-8",
  );

  const documentTypeNames: string[] = [];
  const validationErrors: string[] = [];

  await Promise.all(
    config.documentTypes.map(async (docType) => {
      documentTypeNames.push(docType.name);

      const files = await globby(docType.filePathPattern, {
        cwd: path.join(process.cwd(), config.contentDirPath),
        absolute: true,
      });

      const docTypeOutput: ParsedContent[] = await Promise.all(
        files.map(async (file) => {
          const raw = await fs.readFile(file, "utf-8");

          let data: Record<string, any>;
          let body: string;

          try {
            const parsed = parseFrontmatter(raw, file);
            data = parsed.data;
            body = parsed.body;

            for (const [fieldName, fieldType] of Object.entries(
              docType.fields,
            )) {
              const value = data[fieldName];
              const isValid =
                fieldType.type === "array" || fieldType.type === "list"
                  ? validateFieldType(value, fieldType.type, fieldType.items)
                  : validateFieldType(value, fieldType.type);

              if (!isValid) {
                const relativeFilePath = path.relative(process.cwd(), file);
                validationErrors.push(
                  `${colors.red}Invalid${colors.reset} type for field "${colors.gray}${fieldName}${colors.reset}" in file "${colors.gray}${relativeFilePath}${colors.reset}". Expected "${colors.yellow}${fieldType.type}${colors.reset}", got "${colors.cyan}${typeof value}${colors.reset}".`,
                );
              }
            }
          } catch (error) {
            throw new Error((error as any).message);
          }

          const html = await marked(body);

          const computedFields = docType.computedFields || {};
          const computedData: Record<string, any> = {};
          for (const [fieldName, { resolve }] of Object.entries(
            computedFields,
          )) {
            computedData[fieldName] = resolve({ ...data, raw: body, html });
          }

          return {
            typeName: docType.name,
            ...data,
            ...computedData,
            raw: body,
            html,
          } as ParsedContent;
        }),
      );

      const cacheFilePath = path.join(cacheDir, `${docType.name}.json`);
      const docTypeDir = path.join(generatedDir, docType.name);
      const indexFilePath = path.join(docTypeDir, "_index.json");

      await Promise.all([
        fs.writeFile(cacheFilePath, JSON.stringify(docTypeOutput, null, 2)),
        fs.mkdir(docTypeDir, { recursive: true }),
        fs.writeFile(indexFilePath, JSON.stringify(docTypeOutput, null, 2)),
      ]);

      output.push(...docTypeOutput);
    }),
  );

  if (validationErrors.length > 0) {
    const longestErrorLength = validationErrors.reduce((a, b) =>
      a.length > b.length ? a : b,
    ).length;

    logger.error("Validating field types:", "contentkit");
    console.log(
      `${colors.gray}-${colors.reset}`.repeat(longestErrorLength / 1.3 + 2),
    );
    console.log(
      validationErrors
        .map((error) => error.padEnd(longestErrorLength + 2))
        .join("\n"),
    );

    process.exit(1);
  }

  const isESM = config.outputFormat === "esm";

  const indexFileContent = generateIndexFile(config, cacheDir, isESM);
  const indexFilePath = path.join(generatedDir, `index.js`);
  await fs.writeFile(indexFilePath, indexFileContent);

  const generateTypes = config.generateTypes !== false;
  if (generateTypes) {
    const typesFileContent = generateTypeScriptTypesFile(config, generatedDir);
    const typesFilePath = path.join(generatedDir, "types.d.ts");
    const indexTypesFileContent = generateIndexTypesFile(config);
    const indexTypesFilePath = path.join(generatedDir, "index.d.ts");

    await Promise.all([
      fs.writeFile(typesFilePath, typesFileContent),
      fs.writeFile(indexTypesFilePath, indexTypesFileContent),
    ]);
  }
}
