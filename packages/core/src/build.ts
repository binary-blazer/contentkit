/**
 * Copyright (c) Jonas Franke and the ContentKit Contributors
 * SPDX-License-Identifier: BSD-3-Clause
 */

import fs from "node:fs/promises";
import fsSync from "node:fs";
import path from "node:path";
import process from "node:process";
import { marked } from "marked";
import { loadConfig } from "@ckjs/utils/load-config";
import { logger, colors } from "@ckjs/utils/logger";
import { parseInternal as parseFrontmatter } from "@ckjs/matter";
import type { ContentKitConfig, ParsedContent } from "@ckjs/types";
import { validateFieldType } from "./utils/validateFieldType";
import { generateTypeScriptTypesFile } from "./utils/generateTypeScriptTypesFile";
import { generateIndexTypesFile } from "./utils/generateIndexTypesFile";
import { generateIndexFile } from "./utils/generateIndexFile";

export async function build(config: ContentKitConfig) {
  const { globby } = await import("globby");

  const output: ParsedContent[] = [];
  const cacheDir = path.join(".contentkit", ".cache");
  const generatedDir = path.join(".contentkit", "generated");
  const packageJsonPath = path.join(".contentkit", "package.json");

  await fs.mkdir(cacheDir, { recursive: true });
  await fs.mkdir(generatedDir, { recursive: true });

  const randomVersion = `0.0.0-${Math.random().toString(36).substring(2, 10).toUpperCase()}`;

  const packageJsonContent = {
    name: "dot-contentkit",
    description: "This package is auto-generated by ContentKit",
    version: randomVersion,
    exports: {
      "./generated": {
        import: "./generated/index.js",
      },
    },
    typesVersions: {
      "*": {
        generated: ["./generated"],
      },
    },
  };

  await fs.writeFile(
    packageJsonPath,
    JSON.stringify(packageJsonContent, null, 2),
  );

  const configNames = [
    "contentkit.config.ts",
    "contentkit.config.js",
    "contentkit.config.mjs",
    "contentkit.config.cjs",
  ];

  let configPath: string | undefined;
  for (const name of configNames) {
    const potentialPath = path.join(process.cwd(), name);
    if (fsSync.existsSync(potentialPath)) {
      configPath = potentialPath;
      break;
    }
  }

  if (!configPath) {
    throw new Error("CONFIG_NOT_FOUND");
  }

  const configStat = fsSync.statSync(configPath);
  const cacheConfigPath = path.join(cacheDir, "config.timestamp");
  let shouldReloadConfig = true;

  if (fsSync.existsSync(cacheConfigPath)) {
    const cachedTimestamp = parseInt(
      fsSync.readFileSync(cacheConfigPath, "utf-8"),
      10,
    );
    shouldReloadConfig = configStat.mtimeMs > cachedTimestamp;
  }

  if (shouldReloadConfig) {
    config = await loadConfig();
    fsSync.writeFileSync(cacheConfigPath, configStat.mtimeMs.toString());
  }

  const documentTypeNames: string[] = [];
  const validationErrors: string[] = [];

  for (const docType of config.documentTypes) {
    documentTypeNames.push(docType.name);

    const files = await globby(docType.filePathPattern, {
      cwd: path.join(process.cwd(), config.contentDirPath),
      absolute: true,
    });

    const docTypeOutput: ParsedContent[] = [];
    for (const file of files) {
      const raw = await fs.readFile(file, "utf-8");

      let data: Record<string, any>;
      let body: string;

      try {
        const parsed = parseFrontmatter(raw, file);
        data = parsed.data;
        body = parsed.body;

        for (const [fieldName, fieldType] of Object.entries(docType.fields)) {
          const value = data[fieldName];
          const isValid =
            fieldType.type === "array" || fieldType.type === "list"
              ? validateFieldType(value, fieldType.type, fieldType.items)
              : validateFieldType(value, fieldType.type);

          if (!isValid) {
            const relativeFilePath = path.relative(process.cwd(), file);
            validationErrors.push(
              `${colors.red}Invalid${colors.reset} type for field "${colors.gray}${fieldName}${colors.reset}" in file "${colors.gray}${relativeFilePath}${colors.reset}". Expected "${colors.yellow}${fieldType.type}${colors.reset}", got "${colors.cyan}${typeof value}${colors.reset}".`,
            );
          }
        }
      } catch (error) {
        throw new Error((error as any).message);
      }

      const html = await marked(body);

      const parsedContent: ParsedContent = {
        typeName: docType.name,
        ...data,
        raw: body,
        html,
      };

      docTypeOutput.push(parsedContent);
    }

    const cacheFilePath = path.join(cacheDir, `${docType.name}.json`);
    await fs.writeFile(cacheFilePath, JSON.stringify(docTypeOutput, null, 2));

    const docTypeDir = path.join(generatedDir, docType.name);
    await fs.mkdir(docTypeDir, { recursive: true });
    const indexFilePath = path.join(docTypeDir, "_index.json");
    await fs.writeFile(indexFilePath, JSON.stringify(docTypeOutput, null, 2));

    output.push(...docTypeOutput);
  }

  if (validationErrors.length > 0) {
    const longestErrorLength = validationErrors.reduce((a, b) =>
      a.length > b.length ? a : b,
    ).length;

    logger.error("Validating field types:", "contentkit");
    console.log(
      `${colors.gray}-${colors.reset}`.repeat(longestErrorLength / 1.3 + 2),
    );
    console.log(
      validationErrors
        .map((error) => error.padEnd(longestErrorLength + 2))
        .join("\n"),
    );

    process.exit(1);
  }

  const isESM = config.outputFormat === "esm";

  const indexFileContent = generateIndexFile(config, cacheDir, isESM);
  const indexFilePath = path.join(generatedDir, `index.js`);
  await fs.writeFile(indexFilePath, indexFileContent);

  const generateTypes = config.generateTypes !== false;
  if (generateTypes) {
    const typesFileContent = generateTypeScriptTypesFile(config, generatedDir);
    const typesFilePath = path.join(generatedDir, "types.d.ts");
    await fs.writeFile(typesFilePath, typesFileContent);

    const indexTypesFileContent = generateIndexTypesFile(config);
    const indexTypesFilePath = path.join(generatedDir, "index.d.ts");
    await fs.writeFile(indexTypesFilePath, indexTypesFileContent);
  }
}
